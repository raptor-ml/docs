"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[6702],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>u});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=a.createContext({}),p=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},c=function(e){var n=p(e.components);return a.createElement(s.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),m=p(t),u=r,h=m["".concat(s,".").concat(u)]||m[u]||d[u]||i;return t?a.createElement(h,o(o({ref:n},c),{},{components:t})):a.createElement(h,o({ref:n},c))}));function u(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,o=new Array(i);o[0]=m;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,o[1]=l;for(var p=2;p<i;p++)o[p]=t[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},840:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>l,toc:()=>p});var a=t(7462),r=(t(7294),t(3905));const i={},o="Lexical elements",l={unversionedId:"reference/pyexp/pyexp-language-definition/lexical-elements",id:"reference/pyexp/pyexp-language-definition/lexical-elements",title:"Lexical elements",description:"A Starlark program consists of one or more modules. Each module is defined by a single UTF-8-encoded text file.",source:"@site/docs/reference/pyexp/pyexp-language-definition/lexical-elements.md",sourceDirName:"reference/pyexp/pyexp-language-definition",slug:"/reference/pyexp/pyexp-language-definition/lexical-elements",permalink:"/docs/reference/pyexp/pyexp-language-definition/lexical-elements",draft:!1,editUrl:"https://github.com/dataploy-ai/docs/tree/master/docs/reference/pyexp/pyexp-language-definition/lexical-elements.md",tags:[],version:"current",frontMatter:{},sidebar:"reference",previous:{title:"Expressions",permalink:"/docs/reference/pyexp/pyexp-language-definition/expressions"},next:{title:"Name binding and variables",permalink:"/docs/reference/pyexp/pyexp-language-definition/name-binding-and-variables"}},s={},p=[{value:"String literals",id:"string-literals",level:2},{value:"String escapes",id:"string-escapes",level:3}],c={toc:p};function d(e){let{components:n,...t}=e;return(0,r.kt)("wrapper",(0,a.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"lexical-elements"},"Lexical elements"),(0,r.kt)("p",null,"A Starlark program consists of one or more modules. Each module is defined by a single UTF-8-encoded text file."),(0,r.kt)("p",null,"A complete grammar of Starlark can be found in grammar.txt. That grammar is presented piecemeal throughout this document in boxes such as this one, which explains the notation:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Grammar notation\n\n- lowercase and 'quoted' items are lexical tokens.\n- Capitalized names denote grammar productions.\n- (...) implies grouping.\n- x | y means either x or y.\n- [x] means x is optional.\n- {x} means x is repeated zero or more times.\n- The end of each declaration is marked with a period.\n")),(0,r.kt)("p",null,"The contents of a Starlark file are broken into a sequence of tokens of five kinds: white space, punctuation, keywords, identifiers, and literals. Each token is formed from the longest sequence of characters that would form a valid token of each kind."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"File = {Statement | newline} eof .\n")),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"White space")," consists of spaces (U+0020), tabs (U+0009), carriage returns (U+000D), and newlines (U+000A). Within a line, white space has no effect other than to delimit the previous token, but newlines, and spaces at the start of a line, are significant tokens."),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Comments"),": A hash character (",(0,r.kt)("inlineCode",{parentName:"p"},"#"),") appearing outside of a string literal marks the start of a comment; the comment extends to the end of the line, not including the newline character. Comments are treated like other white space."),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Punctuation"),": The following punctuation characters or sequences of characters are tokens:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"+    -    *    /    //   %    =\n+=   -=   *=   /=   //=  %=   ==   !=\n^    <    >    <<   >>   &    |\n^=   <=   >=   <<=  >>=  &=   |=\n.    ,    ;    :    ~    **\n(    )    [    ]    {    }\n")),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Keywords"),": The following tokens are keywords and may not be used as identifiers:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"and            elif           in             or\nbreak          else           lambda         pass\ncontinue       for            load           return\ndef            if             not            while\n")),(0,r.kt)("p",null,"The tokens below also may not be used as identifiers although they do not appear in the grammar; they are reserved as possible future keywords:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"as             finally        nonlocal\nassert         from           raise\nclass          global         try\ndel            import         with\nexcept         is             yield\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Implementation note:")," The Go implementation permits ",(0,r.kt)("inlineCode",{parentName:"p"},"assert")," to be used as an identifier, and this feature is widely used in its tests."),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Identifiers"),": an identifier is a sequence of Unicode letters, decimal digits, and underscores (",(0,r.kt)("inlineCode",{parentName:"p"},"_"),"), not starting with a digit. Identifiers are used as names for values."),(0,r.kt)("p",null,"Examples:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"None    True    len\nx       index   starts_with     arg0\n")),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Literals"),": literals are tokens that denote specific values. Starlark has string, integer, and floating-point literals."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"0                               # int\n123                             # decimal int\n0x7f                            # hexadecimal int\n0o755                           # octal int\n0b1011                          # binary int\n\n0.0     0.       .0             # float\n1e10    1e+10    1e-10\n1.1e10  1.1e+10  1.1e-10\n\n\"hello\"      'hello'            # string\n'''hello'''  \"\"\"hello\"\"\"        # triple-quoted string\nr'hello'     r\"hello\"           # raw string literal\n")),(0,r.kt)("p",null,"Integer and floating-point literal tokens are defined by the following grammar:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"int         = decimal_lit | octal_lit | hex_lit | binary_lit .\ndecimal_lit = ('1' \u2026 '9') {decimal_digit} | '0' .\noctal_lit   = '0' ('o'|'O') octal_digit {octal_digit} .\nhex_lit     = '0' ('x'|'X') hex_digit {hex_digit} .\nbinary_lit  = '0' ('b'|'B') binary_digit {binary_digit} .\n\nfloat     = decimals '.' [decimals] [exponent]\n          | decimals exponent\n          | '.' decimals [exponent]\n          .\ndecimals  = decimal_digit {decimal_digit} .\nexponent  = ('e'|'E') ['+'|'-'] decimals .\n\ndecimal_digit = '0' \u2026 '9' .\noctal_digit   = '0' \u2026 '7' .\nhex_digit     = '0' \u2026 '9' | 'A' \u2026 'F' | 'a' \u2026 'f' .\nbinary_digit  = '0' | '1' .\n")),(0,r.kt)("h2",{id:"string-literals"},"String literals"),(0,r.kt)("p",null,"A Starlark string literal denotes a string value. In its simplest form, it consists of the desired text surrounded by matching single- or double-quotation marks:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"\"abc\"\n'abc'\n")),(0,r.kt)("p",null,"Literal occurrences of the chosen quotation mark character must be escaped by a preceding backslash. So, if a string contains several of one kind of quotation mark, it may be convenient to quote the string using the other kind, as in these examples:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'\'Have you read "To Kill a Mockingbird?"\'\n"Yes, it\'s a classic."\n\n"Have you read \\"To Kill a Mockingbird?\\""\n\'Yes, it\\\'s a classic.\'\n')),(0,r.kt)("p",null,"Literal occurrences of the ",(0,r.kt)("em",{parentName:"p"},"opposite")," kind of quotation mark, such as an apostrophe within a double-quoted string literal, may be escaped by a backslash, but this is not necessary: ",(0,r.kt)("inlineCode",{parentName:"p"},'"it\'s"')," and ",(0,r.kt)("inlineCode",{parentName:"p"},'"it\\\'s"')," are equivalent."),(0,r.kt)("h3",{id:"string-escapes"},"String escapes"),(0,r.kt)("p",null,"Within a string literal, the backslash character ",(0,r.kt)("inlineCode",{parentName:"p"},"\\")," indicates the start of an ",(0,r.kt)("em",{parentName:"p"},"escape sequence"),", a notation for expressing things that are impossible or awkward to write directly."),(0,r.kt)("p",null,"The following ",(0,r.kt)("em",{parentName:"p"},"traditional escape sequences")," represent the ASCII control codes 7-13:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"\\a   \\x07 alert or bell\n\\b   \\x08 backspace\n\\f   \\x0C form feed\n\\n   \\x0A line feed\n\\r   \\x0D carriage return\n\\t   \\x09 horizontal tab\n\\v   \\x0B vertical tab\n")),(0,r.kt)("p",null,"A ",(0,r.kt)("em",{parentName:"p"},"literal backslash")," is written using the escape ",(0,r.kt)("inlineCode",{parentName:"p"},"\\\\"),"."),(0,r.kt)("p",null,"An ",(0,r.kt)("em",{parentName:"p"},"escaped newline"),"---that is, a backslash at the end of a line---is ignored, allowing a long string to be split across multiple lines of the source file."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'"abc\\\ndef"            # "abcdef"\n')),(0,r.kt)("p",null,"An ",(0,r.kt)("em",{parentName:"p"},"octal escape")," encodes a single byte using its octal value. It consists of a backslash followed by one, two, or three octal digits ","[","0-7]. It is error if the value is greater than decimal 255."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'\'\\0\'            # "\\x00"  a string containing a single NUL byte\n\'\\12\'           # "\\n"    octal 12 = decimal 10\n\'\\101-\\132\'     # "A-Z"\n\'\\119\'          # "\\t9"   = "\\11" + "9"\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Implementation note:")," The Java implementation encodes strings using UTF-16, so an octal escape encodes a single UTF-16 code unit. Octal escapes for values above 127 are therefore not portable across implementations. There is little reason to use octal escapes in new code."),(0,r.kt)("p",null,"A ",(0,r.kt)("em",{parentName:"p"},"hex escape")," encodes a single byte using its hexadecimal value. It consists of ",(0,r.kt)("inlineCode",{parentName:"p"},"\\x")," followed by exactly two hexadecimal digits ","[","0-9A-Fa-f]."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'"\\x00"          # "\\x00"  a string containing a single NUL byte\n"(\\x20)"        # "( )"   ASCII 0x20 = 32 = space\n\nred, reset = "\\x1b[31m", "\\x1b[0m"  # ANSI terminal control codes for color\n"(" + red + "hello" + reset + ")"   # "(hello)" with red text, if on a terminal\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Implementation note:")," The Java implementation does not support hex escapes."),(0,r.kt)("p",null,"An ordinary string literal may not contain an unescaped newline, but a ",(0,r.kt)("em",{parentName:"p"},"multiline string literal")," may spread over multiple source lines. It is denoted using three quotation marks at start and end. Within it, unescaped newlines and quotation marks (or even pairs of quotation marks) have their literal meaning, but three quotation marks end the literal. This makes it easy to quote large blocks of text with few escapes."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"haiku = '''\nYesterday it worked.\nToday it is not working.\nThat's computers. Sigh.\n'''\n")),(0,r.kt)("p",null,"Regardless of the platform's convention for text line endings---for example, a linefeed (\\n) on UNIX, or a carriage return followed by a linefeed (\\r\\n) on Microsoft Windows---an unescaped line ending in a multiline string literal always denotes a line feed (\\n)."),(0,r.kt)("p",null,"Starlark also supports ",(0,r.kt)("em",{parentName:"p"},"raw string literals"),", which look like an ordinary single- or double-quotation preceded by ",(0,r.kt)("inlineCode",{parentName:"p"},"r"),". Within a raw string literal, there is no special processing of backslash escapes, other than an escaped quotation mark (which denotes a literal quotation mark), or an escaped newline (which denotes a backslash followed by a newline). This form of quotation is typically used when writing strings that contain many quotation marks or backslashes (such as regular expressions or shell commands) to reduce the burden of escaping:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'"a\\nb"      # "a\\nb"  = \'a\' + \'\\n\' + \'b\'\nr"a\\nb"     # "a\\\\nb" = \'a\' + \'\\\\\' + \'n\' + \'b\'\n\n"a\\\nb"      # "ab"\nr"a\\\nb"      # "a\\\\\\nb"\n')),(0,r.kt)("p",null,"It is an error for a backslash to appear within a string literal other than as part of one of the escapes described above."),(0,r.kt)("p",null,"TODO: define indent, outdent, semicolon, newline, eof"))}d.isMDXComponent=!0}}]);